<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cve-Analysis on Bayesian Blogs</title>
    <link>http://localhost:1313/tags/cve-analysis/</link>
    <description>Recent content in Cve-Analysis on Bayesian Blogs</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 13 Feb 2026 19:47:59 -0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/cve-analysis/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>XSS via Code Injection in NiceGUI</title>
      <link>http://localhost:1313/posts/nicegui-xss/</link>
      <pubDate>Fri, 13 Feb 2026 19:47:59 -0800</pubDate>
      <guid>http://localhost:1313/posts/nicegui-xss/</guid>
      <description>&lt;p&gt;NiceGUI is a Python framework that lets you build web-based UIs directly in Python, with no HTML/CSS/JS required. It handles both the frontend and backend, making it easy to create interactive dashboards, tools, and apps with a clean, declarative API. To be able to do this, NiceGUI has functions that construct Javascript code from input received through Python code. One of these functions, &lt;code&gt;run_method()&lt;/code&gt;, was vulnerable to quote injection that allowed providing input in ways that led to XSS.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Crashing Fiber via go-fuzz</title>
      <link>http://localhost:1313/posts/cve-2025-54801/</link>
      <pubDate>Tue, 29 Jul 2025 19:43:13 -0700</pubDate>
      <guid>http://localhost:1313/posts/cve-2025-54801/</guid>
      <description>&lt;p&gt;For the past couple months (albeit very sporadically), I have been getting my feet wet in the world of fuzzing. I have been alluding to &amp;ldquo;fuzzing experiments&amp;rdquo; in my recent blogs - and I am happy to state that my experiments have yielded a result! I found an exploitable crash in the &lt;a href=&#34;https://github.com/gofiber/fiber&#34;&gt;Fiber&lt;/a&gt; framework. When using Fiber&amp;rsquo;s &lt;code&gt;Ctx.BodyParser&lt;/code&gt; to parse form data containing a large numeric key that represents a slice index (e.g., &lt;code&gt;test.18446744073704&lt;/code&gt;), the application crashes due to an out-of-bounds slice allocation in the underlying schema decoder. This issue was discovered in Fiber v2.52.8 and has been fixed in v2.52.9. It has been assigned &lt;a href=&#34;https://github.com/gofiber/fiber/security/advisories/GHSA-qx2q-88mx-vhg7&#34;&gt;CVE-2025-54801&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>I Ran Free SAST Tools on chi and Found a GHSA</title>
      <link>http://localhost:1313/posts/ghsa-vrw8-fxc6-2r93/</link>
      <pubDate>Sun, 29 Jun 2025 09:11:02 -0700</pubDate>
      <guid>http://localhost:1313/posts/ghsa-vrw8-fxc6-2r93/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/go-chi/chi/security/advisories/GHSA-vrw8-fxc6-2r93&#34;&gt;GHSA-vrw8-fxc6-2r93&lt;/a&gt; is a Host Header Injection issue in the &lt;a href=&#34;https://github.com/go-chi/chi&#34;&gt;chi framework&lt;/a&gt; which allows arbitrary redirect to any domain while redirecting slashes. I did not receive a CVE for this finding &amp;ldquo;Given the lower impact (can&amp;rsquo;t be exploited in browser or email client)&amp;rdquo; (verbatim from the maintainers) - which I can agree with to some extent. I will say though, that lower impact vulnerabilities should also get CVEs, else there would be no CVSS &amp;ldquo;low&amp;rdquo; score CVEs. My slight disagreement is probably more influenced by me wanting CVEs to my name than a technical outlook. Having said that, GHSAs are pretty recognized too, and in these parts, we take what we get.&lt;/p&gt;</description>
    </item>
    <item>
      <title>I Ran Free SAST Tools on OpenEMR and Found a CVE</title>
      <link>http://localhost:1313/posts/cve-2025-30161/</link>
      <pubDate>Wed, 19 Mar 2025 19:37:34 -0700</pubDate>
      <guid>http://localhost:1313/posts/cve-2025-30161/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://nvd.nist.gov/vuln/detail/CVE-2025-30161&#34;&gt;CVE-2025-30161&lt;/a&gt;(&lt;a href=&#34;https://github.com/openemr/openemr/security/advisories/GHSA-59rv-645x-rg6p&#34;&gt;Github Advisory&lt;/a&gt;) is a stored XSS vulnerability in the bronchitis form component of OpenEMR. It allows anyone with access to edit a bronchitis form to inject malicious javascript payload into the form and run the payload in the context of other users including administrators.&lt;/p&gt;&#xA;&lt;h2 id=&#34;background&#34;&gt;Background&lt;/h2&gt;&#xA;&lt;p&gt;I am a big proponent of open source static analysis engines like &lt;a href=&#34;https://github.com/semgrep/semgrep&#34;&gt;Semgrep&lt;/a&gt; and tools like &lt;a href=&#34;https://docs.snyk.io/scan-with-snyk/snyk-code&#34;&gt;Snyk Code&lt;/a&gt; that provide a free tier. One of the biggest selling point for both Semgrep and Snyk is that they allow writing your own rules. I have written many Semgrep rules at my job or otherwise and have found the rule language easy to learn and understand, while also providing very powerful features such as taint tracking and autofixing. Snyk&amp;rsquo;s &lt;a href=&#34;https://docs.snyk.io/scan-with-snyk/snyk-code/snyk-code-custom-rules/create-custom-rule&#34;&gt;custom rule&lt;/a&gt; support is currently in preview as of the time of writing. Both Semgrep and Snyk also have a set of pre-built rules. In the Semgrep world they are called community rules and can be found in this &lt;a href=&#34;https://github.com/semgrep/semgrep-rules&#34;&gt;repo&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Not a CVE: Using Airflow via Docker Can Lead to Arbitrary Code Execution</title>
      <link>http://localhost:1313/posts/reversing-airflow-patches/</link>
      <pubDate>Sun, 12 Jan 2025 00:08:05 -0700</pubDate>
      <guid>http://localhost:1313/posts/reversing-airflow-patches/</guid>
      <description>&lt;p&gt;I have been reading quite a few blogs about analyzing patches for CVEs and generating exploits based on the difference in code between the vulnerable and the fixed versions (&lt;code&gt;diff&lt;/code&gt;). One of my favorites is &lt;a href=&#34;https://www.assetnote.io/resources/research/two-bytes-is-plenty-fortigate-rce-with-cve-2024-21762&#34;&gt;this blog&lt;/a&gt; from the folks at Assetnote about a CVE in Fortigate. While this level of reverse engineering is waaaay beyond what I can even think of attempting, I also read articles about simpler exercises, such as &lt;a href=&#34;https://blog.securelayer7.net/arbitrary-code-execution-in-apache-airflow/&#34;&gt;this&lt;/a&gt; for a CVE in Apache Airflow - which is a direct inspiration for this blog.&lt;/p&gt;</description>
    </item>
    <item>
      <title>CVE-2024-47821: Remote Code Execution in PyLoad</title>
      <link>http://localhost:1313/posts/cve-2024-47821/</link>
      <pubDate>Fri, 25 Oct 2024 17:00:09 -0800</pubDate>
      <guid>http://localhost:1313/posts/cve-2024-47821/</guid>
      <description>&lt;p&gt;I found my first CVE! &lt;a href=&#34;https://www.cve.org/CVERecord?id=CVE-2024-47821&#34;&gt;CVE-2024-47821&lt;/a&gt; (&lt;a href=&#34;https://github.com/pyload/pyload/security/advisories/GHSA-w7hq-f2pj-c53g&#34;&gt;GitHub Advisory&lt;/a&gt;) is a remote code execution vulnerability in &lt;a href=&#34;https://pyload.net/&#34;&gt;PyLoad&lt;/a&gt;. PyLoad is an open source download manager written in Python. The folder &lt;code&gt;~/.pyload/scripts&lt;/code&gt; on the server where PyLoad is installed has scripts which are run when certain actions are completed, for e.g. a download is finished. By downloading a executable file to a folder in &lt;code&gt;~/.pyload/scripts&lt;/code&gt; and performing the respective action, remote code execution can be achieved. A file can be downloaded to such a folder by changing the download folder to a folder in &lt;code&gt;~/.pyload/scripts&lt;/code&gt; path and using the &lt;code&gt;/flashgot&lt;/code&gt; API to download the file.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Analyzing new-ish CVEs in PyLoad</title>
      <link>http://localhost:1313/posts/pyload-cves/</link>
      <pubDate>Sat, 20 Apr 2024 07:56:09 -0700</pubDate>
      <guid>http://localhost:1313/posts/pyload-cves/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://pyload.net/&#34;&gt;PyLoad&lt;/a&gt; is an open source download manager written in Python. I first came across PyLoad while solving a HackTheBox machine (PC). Solving the machine required exploiting a pre-auth RCE (&lt;a href=&#34;https://nvd.nist.gov/vuln/detail/CVE-2023-0297&#34;&gt;CVE-2023-0297&lt;/a&gt;). I then rediscovered PyLoad when I was looking for CVEs to analyze. My intention was to analyze around 3-4 CVEs in the same product and PyLoad fit the bill perfectly, as there were 4 CVEs disclosed in January and February 2024. In this article, I will explain the CVEs, examine the provided proof of concepts, and evaluate the fixes.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
